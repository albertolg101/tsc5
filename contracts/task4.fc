#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

const int INF = (1 << (30 + 10));

forall X -> int is_null? (X x) asm "ISNULL";

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";

forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

forall X -> (tuple) to_tuple (X x) asm "NOP";

forall X -> (tuple, ()) ~set_index_var2(tuple t, X value, int i) asm "SETINDEXVAR";

forall X -> (tuple) new_tuple_of(X value, int size) asm """
DUP 1 SETGLOB DEC
REPEAT:<{
    DUP
}>
1 GETGLOB
TUPLEVAR
""";

forall X -> (tuple, ()) ~set_index_var(tuple t, int i, int j, X value) asm """
s3 s2 PUSH2
INDEXVAR 
s2 XCHG0
SETINDEXVAR
SWAP SETINDEXVAR
""";

(int) wrap_distance(int d, int x, int y) inline {
    return (d << 10) + (x << 5) + y;
}

(int, int, int) unwrap_distance(int t) inline {
    return (t >> 10, (t >> 5) & 0x1F, t & 0x1F);
}

(tuple, tuple) ~get_list(tuple d) inline {
    tuple temp = null();
    tuple ans = null();
    int min_d = INF;

    while (~ d.is_null?()) {
        int td = d~pop_back();
        if ((td >> 10) > min_d) {
            temp~push_back(td);
        }
        elseif ((td >> 10) == min_d) {
            ans~push_back(td);
        }
        else { ;; (td >> 10) < min_d
            min_d = td >> 10;
            while (~ ans.is_null?()) {
                temp~push_back(ans~pop_back());
            }
            ans~push_back(td);
        }
    }

    return (temp, ans);
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;; start node
    int sx = 0;
    int sy = 0;

    ;; end node
    int ex = 0;
    int ey = 0;
    
    
    int i = 0;
    int j = 0;
    repeat(n) {
        j = 0 ;
        repeat(m) {

            int value = maze.at(i).at(j);

            if (value == 83) {
                sx = i;
                sy = j;
            }

            elseif (value == 69) {
                ex = i;
                ey = j;
            }

            j += 1;
        }
        i += 1;
    }

    ;; when you change this remember to change repeat 8 by 4
    tuple dx = to_tuple([1, 0, -1, 0, 1, 1, -1, -1]);
    tuple dy = to_tuple([0, 1, 0, -1, 1, -1, 1, -1]);
    ;; tuple dx = to_tuple([1, 0, -1, 0]);
    ;; tuple dy = to_tuple([0, 1, 0, -1]);

    int cost = 0;
    int x = -1;
    int y = -1;
    tuple d = null();
    tuple t = new_tuple_of(new_tuple_of(INF, m), n);
    tuple list = null();

    t~set_index_var(sx, sy, 0);
    list~push_back(wrap_distance(0, sx, sy));

    repeat(n * m) {

        if (list.is_null?()) {
            list = d~get_list();
        }

        (cost, x, y) = unwrap_distance(list~pop_back());

        if ((x == ex) & (y == ey)) {
            repeat((cost & 0x3FF) - 1) {
                (_, x, y) = unwrap_distance(t.at(x).at(y));
                maze~set_index_var(x, y, 33);
            }

            return (
                cost >> 20,
                (cost >> 10) & 0x3FF,
                cost & 0x3FF,
                maze
            );
        }
        
        i = 0;
        repeat(8) {
            int nx = x + dx.at(i);
            int ny = y + dy.at(i);

            if ((0 <= nx) & (nx < n) & (0 <= ny) & (ny < m)) {
                int target_cost = t.at(nx).at(ny) >> 10;
                int new_cost = cost + 1;
                int value = maze.at(nx).at(ny);

                if (value == 63) {
                    new_cost += (1 << 10);
                }
                elseif (value == 88) {
                    new_cost += (1 << 20);
                }

                if (target_cost > new_cost) {
                    t~set_index_var(nx, ny, wrap_distance(new_cost, x, y));
                    d~push_back(wrap_distance(new_cost, nx, ny));
                }
            }

            i += 1;
        }
    }

    return (0, 0, 0, null());
}
