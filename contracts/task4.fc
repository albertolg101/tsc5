#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

const int INF = (1 << (30 + 10 + 1));

forall X -> (tuple) to_tuple (X x) asm "NOP";

forall X -> (tuple, ()) ~set_index_var2(tuple t, X value, int i) asm "SETINDEXVAR";

forall X -> (tuple) new_tuple_of(X value, int size) asm """
DUP 1 SETGLOB DEC
REPEAT:<{
    DUP
}>
1 GETGLOB
TUPLEVAR
""";

forall X -> (tuple, ()) ~set_index_var(tuple t, int i, int j, X value) asm """
s3 s2 PUSH2
INDEXVAR 
s2 XCHG0
SETINDEXVAR
SWAP SETINDEXVAR
""";

(int) get_cost(int value) inline {
    if (value == 63) {
        return (1 << 10) + 1;
    }
    elseif (value == 88) {
        return (1 << 20) + 1;
    }
    
    return 1;
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;; start node
    int sx = 0;
    int sy = 0;

    ;; end node
    int ex = 0;
    int ey = 0;
    
    tuple t = new_tuple_of(new_tuple_of(INF, m), n);

    int i = 0;
    int j = 0;
    repeat(n) {
        j = 0 ;
        repeat(m) {

            int value = maze.at(i).at(j);

            if (value == 83) {
                sx = i;
                sy = j;
            }

            elseif (value == 69) {
                ex = i;
                ey = j;
            }

            j += 1;
        }
        i += 1;
    }

    t~set_index_var(sx, sy, 0);

    tuple dx = to_tuple([1, 0, -1, 0, 1, 1, -1, -1]);
    tuple dy = to_tuple([0, 1, 0, -1, 1, -1, 1, -1]);

    int k = 0;
    int x = -1;
    int y = -1;
    int next_x = -1;
    int next_y = -1;
    int flag = 0;

    repeat(n * m) {
        x = -1;
        y = -1;

        if (flag) {
            next_x = -1;
            next_y = -1;
            flag = 0;
        }

        if (next_x == -1) {
            i = 0;
            repeat(n) {
                j = 0;
                repeat(m) {
            
                    ifnot ( t.at(i).at(j) & 1 ) {
                        if ( x == -1 ) {
                            (x, y) = (i, j);
                            (next_x, next_y) = (-1, -1);
                        } 
                        else {
                            int t1 = t.at(x).at(y) >> 11;
                            int t2 = t.at(i).at(j) >> 11;

                            if ( t1 > t2 ) {
                                (x, y) = (i, j);
                                (next_x, next_y) = (-1, -1);
                            }
                            elseif ( t1 == t2 ) {
                                (next_x, next_y) = (i, j);
                            }
                        }
                    }

                    j += 1;
                }
                i += 1;
            }
        }
        else {
            (x, y) = (next_x, next_y);
            flag = -1;
        }

        if ((x == ex) & (y == ey)) {
            int temp = t.at(x).at(y);
            int cost = temp >> 11;
            int x = (temp >> 6) & 0x1F;
            int y = (temp >> 1) & 0x1F;

            repeat((cost & 0x3FF) - 1) {
                maze~set_index_var(x, y, 33);
                temp = t.at(x).at(y);
                x = (temp >> 6) & 0x1F;
                y = (temp >> 1) & 0x1F;
            }

            return (
                cost >> 20,
                (cost >> 10) & 0x3FF,
                cost & 0x3FF,
                maze
            );
        }
        
        t~set_index_var(x, y, t.at(x).at(y) | 1);
        ;; ~dump(t);

        i = 0;
        repeat(8) {
            int nx = x + dx.at(i);
            int ny = y + dy.at(i);

            if ((0 <= nx) & (nx < n) & (0 <= ny) & (ny < m)) {
                int cost = maze.at(nx).at(ny).get_cost();

                if (t.at(nx).at(ny) > t.at(x).at(y) + (cost << 11)) {
                    t~set_index_var(nx, ny, (((t.at(x).at(y) >> 11) + cost) << 11) + (x << 6) + (y << 1));
                    if ((next_x == -1) & (cost == 1)) {
                        (next_x, next_y) = (nx, ny);
                    }
                }
            }

            i += 1;
        }

        k += 1;
    }

    return (0, 0, 0, null());
}

() test_solve() method_id {
    tuple t1 = to_tuple([83, 88, 88]);
    tuple t2 = to_tuple([46, 46, 46]);
    tuple t3 = to_tuple([46, 46, 69]);
    tuple t = to_tuple([t1, t2, t3]);
    (int a, int b, int c, tuple maze) = solve(3, 3, t);
    ~dump(a);
    ~dump(b);
    ~dump(c);
    ~dump(maze);
}