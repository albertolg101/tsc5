#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
}

const int INF = (1 << (30 + 10));

forall X -> int is_null? (X x) asm "ISNULL";

forall X -> (tuple, ()) push_back (tuple tail, X head) asm "CONS";

forall X -> (tuple, (X)) pop_back (tuple t) asm "UNCONS";

forall X -> (tuple) to_tuple (X x) asm "NOP";

forall X -> (tuple, ()) ~set_index_var2(tuple t, X value, int i) asm "SETINDEXVAR";

forall X -> (tuple) new_tuple_of(X value, int size) asm """
DUP 1 SETGLOB DEC
REPEAT:<{
    DUP
}>
1 GETGLOB
TUPLEVAR
""";

forall X -> (tuple, ()) ~set_index_var(tuple t, int i, int j, X value) asm """
s3 s2 PUSH2
INDEXVAR 
s2 XCHG0
SETINDEXVAR
SWAP SETINDEXVAR
""";


(int) wrap_distance(int d, int x, int y) asm(y d x) """
5 LSHIFT#
ROTREV 10 LSHIFT#
ADD ADD
""";

(int, int, int) unwrap_distance(int t) asm """
DUP 10 RSHIFT# SWAP
DUP 5 RSHIFT# 31 PUSHINT AND SWAP
31 PUSHINT AND
""";

;; (tuple, int, tuple) get_list(tuple d, int d_size) asm """
;; 0 INT 0 SETGLOBVAR           // d_size
;; NULLPUSH 1 SETGLOBVAR        // temp
;; NULLPUSH 2 SETGLOBVAR        // ans
;; 40 PUSHPOW2DEC 3 SETGLOBVAR  // min_d
;; REPEAT:<{
;;     UNCONS
    
;; }>
;; """;

(tuple, int, tuple) get_list(tuple d, int d_size) inline {
    tuple temp = null();
    tuple ans = null();
    int min_d = INF;

    repeat(d_size) {
        int td = d~pop_back();
        if ((td >> 10) > min_d) {
            temp~push_back(td);
        }
        elseif ((td >> 10) == min_d) {
            ans~push_back(td);
            d_size -= 1;
        }
        else { ;; (td >> 10) < min_d
            min_d = td >> 10;
            while (~ ans.is_null?()) {
                temp~push_back(ans~pop_back());
                d_size += 1;
            }
            ans~push_back(td);
            d_size -= 1;
        }
    }

    return (temp, d_size, ans);
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;; start node
    int sx = 0;
    int sy = 0;

    ;; end node
    int ex = 0;
    int ey = 0;
    
    
    int i = 0;
    int j = 0;
    repeat(n) {
        j = 0 ;
        repeat(m) {

            int value = maze.at(i).at(j);

            if (value == 83) {
                sx = i;
                sy = j;
                
                ;; when you change this remember to change repeat 8 by 4
                tuple dx = to_tuple([1, 1, -1, -1, 1, 0, -1, 0]);
                tuple dy = to_tuple([1, -1, 1, -1, 0, 1, 0, -1]);
                ;; tuple dx = to_tuple([1, 0, -1, 0]);
                ;; tuple dy = to_tuple([0, 1, 0, -1]);

                int cost = 0;
                int x = -1;
                int y = -1;
                tuple d = null();
                int d_size = 0;
                tuple t = new_tuple_of(new_tuple_of(INF, m), n);
                tuple list = null();

                t~set_index_var(sx, sy, 0);
                list~push_back(wrap_distance(0, sx, sy));

                repeat(n * m) {

                    if (list.is_null?()) {
                        (d, d_size, list) = d.get_list(d_size);
                    }

                    (cost, x, y) = unwrap_distance(list~pop_back());

                    if (maze.at(x).at(y) == 69) {
                        repeat((cost & 0x3FF) - 1) {
                            (_, x, y) = unwrap_distance(t.at(x).at(y));
                            maze~set_index_var(x, y, 33);
                        }

                        return (
                            cost >> 20,
                            (cost >> 10) & 0x3FF,
                            cost & 0x3FF,
                            maze
                        );
                    }
                    
                    i = 0;
                    repeat(8) {
                        int nx = x + dx.at(i);
                        int ny = y + dy.at(i);

                        if ((0 <= nx) & (nx < n) & (0 <= ny) & (ny < m)) {
                            int target_cost = t.at(nx).at(ny) >> 10;
                            int new_cost = cost + 1;
                            int value = maze.at(nx).at(ny);

                            if (value == 63) {
                                new_cost += (1 << 10);
                            }
                            elseif (value == 88) {
                                new_cost += (1 << 20);
                            }

                            if (target_cost > new_cost) {
                                t~set_index_var(nx, ny, wrap_distance(new_cost, x, y));
                                d~push_back(wrap_distance(new_cost, nx, ny));
                                d_size += 1;
                            }
                        }

                        i += 1;
                    }
                }
            }

            elseif (value == 69) {
                ex = i;
                ey = j;
            }

            j += 1;
        }
        i += 1;
    }


    return (0, 0, 0, null());
}

() test_solve() method_id {
    tuple t1 = to_tuple([83, 46, 88, 88, 46]);
    tuple t2 = to_tuple([46, 46, 63, 46, 63]);
    tuple t3 = to_tuple([88, 88, 63, 88, 88]);
    tuple t4 = to_tuple([46, 88, 63, 88, 69]);
    tuple t = to_tuple([t1, t2, t3, t4]);
    (int a, int b, int c, tuple maze) = solve(4, 5, t);
    ~dump(a);
    ~dump(b);
    ~dump(c);
    ~dump(maze);
}